["^ ","~:rename-macros",["^ "],"~:renames",["^ "],"~:use-macros",["^ ","~$comp-paths","~$com.rpl.specter","~$source","~$cljs.repl","~$defnav","^4"],"~:excludes",["~#set",[]],"~:name","~$ob.clojure","~:imports",null,"~:requires",["^ ","~$s","^4","^4","^4","~$cljs.pprint","^>","^6","^6"],"~:cljs.spec/speced-vars",[],"~:uses",["^ ","~$pprint","^>"],"~:defs",["^ ","~$set-recur-point",["^ ","~:protocol-inline",null,"~:meta",["^ ","~:file","/Users/kyleeschen/Desktop/Ouroboros/ob/src/ob/clojure.cljs","~:line",183,"~:column",7,"~:end-line",183,"~:end-column",22,"~:arglists",["~#list",["~$quote",["^L",[["~$env","~$params","~$body"]]]]]],"^:","~$ob.clojure/set-recur-point","^F","src/ob/clojure.cljs","^J",22,"~:method-params",["^L",[["^N","^O","^P"]]],"~:protocol-impl",null,"~:arglists-meta",["^L",[null,null]],"^H",1,"~:variadic?",false,"^G",183,"~:ret-tag",["^9",["~$clj","~$any"]],"^I",183,"~:max-fixed-arity",3,"~:fn-var",true,"^K",["^L",["^M",["^L",[["^N","^O","^P"]]]]]],"~$gen-evaluation-stream",["^ ","^D",null,"^E",["^ ","^F","/Users/kyleeschen/Desktop/Ouroboros/ob/src/ob/clojure.cljs","^G",70,"^H",7,"^I",70,"^J",28,"^K",["^L",["^M",["^L",[["~$form","^N","~$k"]]]]]],"^:","~$ob.clojure/gen-evaluation-stream","^F","src/ob/clojure.cljs","^J",28,"^R",["^L",[["^10","^N","~$k"]]],"^S",null,"^T",["^L",[null,null]],"^H",1,"^U",false,"^G",70,"^I",70,"^Y",3,"^Z",true,"^K",["^L",["^M",["^L",[["^10","^N","~$k"]]]]]],"~$eval-cc",["^ ","^D",null,"^E",["^ ","^F","/Users/kyleeschen/Desktop/Ouroboros/ob/src/ob/clojure.cljs","^G",218,"^H",7,"^I",218,"^J",14,"^K",["^L",["^M",["^L",[["~$f","~$args","^N","~$k"]]]]]],"^:","~$ob.clojure/eval-cc","^F","src/ob/clojure.cljs","^J",14,"^R",["^L",[["~$f","^13","^N","~$k"]]],"^S",null,"^T",["^L",[null,null]],"^H",1,"^U",false,"^G",218,"^V","^X","^I",218,"^Y",4,"^Z",true,"^K",["^L",["^M",["^L",[["~$f","^13","^N","~$k"]]]]]],"~$pathcache57808",["^ ","~:no-doc",true,"^E",["^ ","~:cljs.analyzer/no-resolve",true,"^16",true,"~:private",true,"^F",null],"^18",true,"^:","~$ob.clojure/pathcache57808","^F","src/ob/clojure.cljs","^H",36,"^G",367,"^17",true,"~:tag","~$com.rpl.specter.impl/CachedPathInfo"],"~$cond*",["^ ","^D",null,"^E",["^ ","~:added","1.0","^F","/Users/kyleeschen/Desktop/Ouroboros/ob/src/ob/clojure.cljs","^J",12,"~:top-fn",["^ ","^U",true,"~:fixed-arity",0,"^Y",0,"^R",[["^L",["~$clauses"]]],"^K",["^L",[["~$&","^1@"]]],"^T",["^L",[null]]],"^H",7,"^G",574,"^I",574,"^K",["^L",["^M",["^L",[["~$&","^1@"]]]]],"~:doc","Takes a set of test/expr pairs. It evaluates each test one at a\n  time.  If a test returns logical true, cond evaluates and returns\n  the value of the corresponding expr and doesn't evaluate any of the\n  other tests or exprs. (cond) returns nil."],"^1=","1.0","^:","~$ob.clojure/cond*","^F","src/ob/clojure.cljs","^J",12,"^1>",["^ ","^U",true,"^1?",0,"^Y",0,"^R",[["^L",["^1@"]]],"^K",["^L",[["~$&","^1@"]]],"^T",["^L",[null]]],"^R",[["^L",["^1@"]]],"^S",null,"^1?",0,"^T",["^L",[null]],"^H",1,"^U",true,"~:methods",[["^ ","^1?",0,"^U",true,"^1:",["^9",["~$cljs.core/List","~$clj-nil"]]]],"^G",574,"^V","^X","^I",574,"^Y",0,"^Z",true,"^K",["^L",[["~$&","^1@"]]],"^1A","Takes a set of test/expr pairs. It evaluates each test one at a\n  time.  If a test returns logical true, cond evaluates and returns\n  the value of the corresponding expr and doesn't evaluate any of the\n  other tests or exprs. (cond) returns nil."],"~$pathcache57844",["^ ","^16",true,"^E",["^ ","^17",true,"^16",true,"^18",true,"^F",null],"^18",true,"^:","~$ob.clojure/pathcache57844","^F","src/ob/clojure.cljs","^H",3,"^G",501,"^17",true,"^1:","^1;"],"~$macroexpand*",["^ ","^D",null,"^E",["^ ","^F","/Users/kyleeschen/Desktop/Ouroboros/ob/src/ob/clojure.cljs","^G",454,"^H",7,"^I",454,"^J",19,"^K",["^L",["^M",["^L",[[["~$op","~$&","^13","~:as","^10"],"^N"]]]]]],"^:","~$ob.clojure/macroexpand*","^F","src/ob/clojure.cljs","^J",19,"^R",["^L",[["~$p__57827","^N"]]],"^S",null,"^T",["^L",[null,null]],"^H",1,"^U",false,"^G",454,"^V",["^9",[null,"^X"]],"^I",454,"^Y",2,"^Z",true,"^K",["^L",["^M",["^L",[[["^1I","~$&","^13","^1J","^10"],"^N"]]]]]],"~$and*",["^ ","^D",null,"^E",["^ ","^F","/Users/kyleeschen/Desktop/Ouroboros/ob/src/ob/clojure.cljs","^G",511,"^H",7,"^I",511,"^J",11,"^K",["^L",["^M",["^L",[[],["~$x"],["~$x","~$&","~$next"]]]]],"^1A","Evaluates exprs one at a time, from left to right. If a form\n  returns logical false (nil or false), and returns that value and\n  doesn't evaluate any of the other expressions, otherwise it returns\n  the value of the last expr. (and) returns true.","^1>",["^ ","^U",true,"^1?",1,"^Y",1,"^R",[[],["~$x"]],"^K",["^L",[[],["~$x"],["~$x","~$&","^1N"]]],"^T",["^L",[null,null,null]]]],"^:","~$ob.clojure/and*","^F","src/ob/clojure.cljs","^J",11,"^1>",["^ ","^U",true,"^1?",1,"^Y",1,"^R",[[],["~$x"]],"^K",["^L",[[],["~$x"],["~$x","~$&","^1N"]]],"^T",["^L",[null,null,null]]],"^R",[[],["~$x"]],"^S",null,"^1?",1,"^T",["^L",[null,null,null]],"^H",1,"^U",true,"^1C",[["^ ","^1?",0,"^U",false,"^1:","~$boolean"],["^ ","^1?",1,"^U",false],["^ ","^1?",1,"^U",true,"^1:",["^9",["~$seq","~$cljs.core/IList"]]]],"^G",511,"^I",511,"^Y",1,"^Z",true,"^K",["^L",[[],["~$x"],["~$x","~$&","^1N"]]],"^1A","Evaluates exprs one at a time, from left to right. If a form\n  returns logical false (nil or false), and returns that value and\n  doesn't evaluate any of the other expressions, otherwise it returns\n  the value of the last expr. (and) returns true."],"~$->>*",["^ ","^D",null,"^E",["^ ","^1=","1.1","^F","/Users/kyleeschen/Desktop/Ouroboros/ob/src/ob/clojure.cljs","^J",11,"^1>",["^ ","^U",true,"^1?",1,"^Y",1,"^R",[["^L",["~$x","~$forms"]]],"^K",["^L",[["~$x","~$&","^1T"]]],"^T",["^L",[null]]],"^H",7,"^G",550,"^I",550,"^K",["^L",["^M",["^L",[["~$x","~$&","^1T"]]]]],"^1A","Threads the expr through the forms. Inserts x as the\n  last item in the first form, making a list of it if it is not a\n  list already. If there are more forms, inserts the first form as the\n  last item in second form, etc."],"^1=","1.1","^:","~$ob.clojure/->>*","^F","src/ob/clojure.cljs","^J",11,"^1>",["^ ","^U",true,"^1?",1,"^Y",1,"^R",[["^L",["~$x","^1T"]]],"^K",["^L",[["~$x","~$&","^1T"]]],"^T",["^L",[null]]],"^R",[["^L",["~$x","^1T"]]],"^S",null,"^1?",1,"^T",["^L",[null]],"^H",1,"^U",true,"^1C",[["^ ","^1?",1,"^U",true]],"^G",550,"^V","^X","^I",550,"^Y",1,"^Z",true,"^K",["^L",[["~$x","~$&","^1T"]]],"^1A","Threads the expr through the forms. Inserts x as the\n  last item in the first form, making a list of it if it is not a\n  list already. If there are more forms, inserts the first form as the\n  last item in second form, etc."],"~$letfn-fn->binding-pairs",["^ ","^D",null,"^E",["^ ","^F","/Users/kyleeschen/Desktop/Ouroboros/ob/src/ob/clojure.cljs","^G",327,"^H",7,"^I",327,"^J",30,"^K",["^L",["^M",["^L",[[["~$fname","~$&","^13","^1J","^10"]]]]]]],"^:","~$ob.clojure/letfn-fn->binding-pairs","^F","src/ob/clojure.cljs","^J",30,"^R",["^L",[["~$p__57793"]]],"^S",null,"^T",["^L",[null,null]],"^H",1,"^U",false,"^G",327,"^V","~$cljs.core/IVector","^I",327,"^Y",1,"^Z",true,"^K",["^L",["^M",["^L",[[["^1W","~$&","^13","^1J","^10"]]]]]]],"~$eval-let-forms",["^ ","^D",null,"^E",["^ ","^F","/Users/kyleeschen/Desktop/Ouroboros/ob/src/ob/clojure.cljs","^G",361,"^H",7,"^I",361,"^J",21,"^K",["^L",["^M",["^L",[[["^1I","~$bindings","^P","^1J","^10"],"^N","~$k"]]]]]],"^:","~$ob.clojure/eval-let-forms","^F","src/ob/clojure.cljs","^J",21,"^R",["^L",[["~$p__57804","^N","~$k"]]],"^S",null,"^T",["^L",[null,null]],"^H",1,"^U",false,"^G",361,"^V","^X","^I",361,"^Y",3,"^Z",true,"^K",["^L",["^M",["^L",[[["^1I","^20","^P","^1J","^10"],"^N","~$k"]]]]]],"~$cc?",["^ ","^D",null,"^E",["^ ","^F","/Users/kyleeschen/Desktop/Ouroboros/ob/src/ob/clojure.cljs","^G",214,"^H",7,"^I",214,"^J",10,"^K",["^L",["^M",["^L",[["^1I"]]]]]],"^:","~$ob.clojure/cc?","^F","src/ob/clojure.cljs","^J",10,"^R",["^L",[["^1I"]]],"^S",null,"^T",["^L",[null,null]],"^H",1,"^U",false,"^G",214,"^V","^X","^I",214,"^Y",1,"^Z",true,"^K",["^L",["^M",["^L",[["^1I"]]]]]],"~$eval-invoke",["^ ","^D",null,"^E",["^ ","^F","/Users/kyleeschen/Desktop/Ouroboros/ob/src/ob/clojure.cljs","^G",206,"^H",7,"^I",206,"^J",18,"^K",["^L",["^M",["^L",[["~$f","^13","^N","~$k"]]]]]],"^:","~$ob.clojure/eval-invoke","^F","src/ob/clojure.cljs","^J",18,"^R",["^L",[["~$f","^13","^N","~$k"]]],"^S",null,"^T",["^L",[null,null]],"^H",1,"^U",false,"^G",206,"^V","~$cljs.core/IMap","^I",206,"^Y",4,"^Z",true,"^K",["^L",["^M",["^L",[["~$f","^13","^N","~$k"]]]]]],"~$RESTORE-MACRO",["^ ","^:","~$ob.clojure/RESTORE-MACRO","^F","src/ob/clojure.cljs","^G",468,"^H",1,"^I",468,"^J",19,"^E",["^ ","^F","/Users/kyleeschen/Desktop/Ouroboros/ob/src/ob/clojure.cljs","^G",468,"^H",6,"^I",468,"^J",19],"^1:",["^9",["^W","~$cljs.core/MetaFn","^1E"]]],"~$->*",["^ ","^D",null,"^E",["^ ","^1=","1.0","^F","/Users/kyleeschen/Desktop/Ouroboros/ob/src/ob/clojure.cljs","^J",10,"^1>",["^ ","^U",true,"^1?",1,"^Y",1,"^R",[["^L",["~$x","^1T"]]],"^K",["^L",[["~$x","~$&","^1T"]]],"^T",["^L",[null]]],"^H",7,"^G",533,"^I",533,"^K",["^L",["^M",["^L",[["~$x","~$&","^1T"]]]]],"^1A","Threads the expr through the forms. Inserts x as the\n  second item in the first form, making a list of it if it is not a\n  list already. If there are more forms, inserts the first form as the\n  second item in second form, etc."],"^1=","1.0","^:","~$ob.clojure/->*","^F","src/ob/clojure.cljs","^J",10,"^1>",["^ ","^U",true,"^1?",1,"^Y",1,"^R",[["^L",["~$x","^1T"]]],"^K",["^L",[["~$x","~$&","^1T"]]],"^T",["^L",[null]]],"^R",[["^L",["~$x","^1T"]]],"^S",null,"^1?",1,"^T",["^L",[null]],"^H",1,"^U",true,"^1C",[["^ ","^1?",1,"^U",true]],"^G",533,"^V","^X","^I",533,"^Y",1,"^Z",true,"^K",["^L",[["~$x","~$&","^1T"]]],"^1A","Threads the expr through the forms. Inserts x as the\n  second item in the first form, making a list of it if it is not a\n  list already. If there are more forms, inserts the first form as the\n  second item in second form, etc."],"~$when*",["^ ","^D",null,"^E",["^ ","^1=","1.0","^F","/Users/kyleeschen/Desktop/Ouroboros/ob/src/ob/clojure.cljs","^J",12,"^1>",["^ ","^U",true,"^1?",1,"^Y",1,"^R",[["^L",["~$test","^P"]]],"^K",["^L",[["^2>","~$&","^P"]]],"^T",["^L",[null]]],"^H",7,"^G",588,"^I",588,"^K",["^L",["^M",["^L",[["^2>","~$&","^P"]]]]],"^1A","Evaluates test. If logical true, evaluates body in an implicit do."],"^1=","1.0","^:","~$ob.clojure/when*","^F","src/ob/clojure.cljs","^J",12,"^1>",["^ ","^U",true,"^1?",1,"^Y",1,"^R",[["^L",["^2>","^P"]]],"^K",["^L",[["^2>","~$&","^P"]]],"^T",["^L",[null]]],"^R",[["^L",["^2>","^P"]]],"^S",null,"^1?",1,"^T",["^L",[null]],"^H",1,"^U",true,"^1C",[["^ ","^1?",1,"^U",true,"^1:","^1D"]],"^G",588,"^V","^X","^I",588,"^Y",1,"^Z",true,"^K",["^L",[["^2>","~$&","^P"]]],"^1A","Evaluates test. If logical true, evaluates body in an implicit do."],"~$evaluate",["^ ","^D",null,"^E",["^ ","^F","/Users/kyleeschen/Desktop/Ouroboros/ob/src/ob/clojure.cljs","^G",44,"^H",7,"^I",44,"^J",15,"^K",["^L",["^M",["^L",[["^10","^N","~$k"]]]]]],"^:","~$ob.clojure/evaluate","^F","src/ob/clojure.cljs","^J",15,"^R",["^L",[["^10","^N","~$k"]]],"^S",null,"^T",["^L",[null,null]],"^H",1,"^U",false,"^G",44,"^I",44,"^Y",3,"^Z",true,"^K",["^L",["^M",["^L",[["^10","^N","~$k"]]]]]],"~$when-not*",["^ ","^D",null,"^E",["^ ","^1=","1.0","^F","/Users/kyleeschen/Desktop/Ouroboros/ob/src/ob/clojure.cljs","^J",16,"^1>",["^ ","^U",true,"^1?",1,"^Y",1,"^R",[["^L",["^2>","^P"]]],"^K",["^L",[["^2>","~$&","^P"]]],"^T",["^L",[null]]],"^H",7,"^G",595,"^I",595,"^K",["^L",["^M",["^L",[["^2>","~$&","^P"]]]]],"^1A","Evaluates test. If logical false, evaluates body in an implicit do."],"^1=","1.0","^:","~$ob.clojure/when-not*","^F","src/ob/clojure.cljs","^J",16,"^1>",["^ ","^U",true,"^1?",1,"^Y",1,"^R",[["^L",["^2>","^P"]]],"^K",["^L",[["^2>","~$&","^P"]]],"^T",["^L",[null]]],"^R",[["^L",["^2>","^P"]]],"^S",null,"^1?",1,"^T",["^L",[null]],"^H",1,"^U",true,"^1C",[["^ ","^1?",1,"^U",true,"^1:","^1D"]],"^G",595,"^V","^X","^I",595,"^Y",1,"^Z",true,"^K",["^L",[["^2>","~$&","^P"]]],"^1A","Evaluates test. If logical false, evaluates body in an implicit do."],"~$lambda?",["^ ","^D",null,"^E",["^ ","^F","/Users/kyleeschen/Desktop/Ouroboros/ob/src/ob/clojure.cljs","^G",177,"^H",7,"^I",177,"^J",14,"^K",["^L",["^M",["^L",[["^1I"]]]]]],"^:","~$ob.clojure/lambda?","^F","src/ob/clojure.cljs","^J",14,"^R",["^L",[["^1I"]]],"^S",null,"^T",["^L",[null,null]],"^H",1,"^U",false,"^G",177,"^V","^1P","^I",177,"^Y",1,"^Z",true,"^K",["^L",["^M",["^L",[["^1I"]]]]]],"~$thread-ks",["^ ","^D",null,"^E",["^ ","^F","/Users/kyleeschen/Desktop/Ouroboros/ob/src/ob/clojure.cljs","^G",88,"^H",7,"^I",88,"^J",16,"^K",["^L",["^M",["^L",[["~$combining-fn"]]]]]],"^:","~$ob.clojure/thread-ks","^F","src/ob/clojure.cljs","^J",16,"^R",["^L",[["^2G"]]],"^S",null,"^T",["^L",[null,null]],"^H",1,"^U",false,"^G",88,"^V","~$function","^I",88,"^Y",1,"^Z",true,"^K",["^L",["^M",["^L",[["^2G"]]]]]],"~$eval-lambda",["^ ","^D",null,"^E",["^ ","^F","/Users/kyleeschen/Desktop/Ouroboros/ob/src/ob/clojure.cljs","^G",187,"^H",7,"^I",187,"^J",18,"^K",["^L",["^M",["^L",[["~$f","^13","^N","~$k"]]]]]],"^:","~$ob.clojure/eval-lambda","^F","src/ob/clojure.cljs","^J",18,"^R",["^L",[["~$f","^13","^N","~$k"]]],"^S",null,"^T",["^L",[null,null]],"^H",1,"^U",false,"^G",187,"^V","^27","^I",187,"^Y",4,"^Z",true,"^K",["^L",["^M",["^L",[["~$f","^13","^N","~$k"]]]]]],"~$letfn-fn",["^ ","^:","~$ob.clojure/letfn-fn","^F","src/ob/clojure.cljs","^G",325,"^H",1,"^I",325,"^J",14,"^E",["^ ","^F","/Users/kyleeschen/Desktop/Ouroboros/ob/src/ob/clojure.cljs","^G",325,"^H",6,"^I",325,"^J",14],"^1:","~$cljs.core/Symbol"],"~$pathcache57833",["^ ","^16",true,"^E",["^ ","^17",true,"^16",true,"^18",true,"^F",null],"^18",true,"^:","~$ob.clojure/pathcache57833","^F","src/ob/clojure.cljs","^H",3,"^G",469,"^17",true,"^1:","^1;"],"~$lazy-seq*",["^ ","^D",null,"^E",["^ ","^F","/Users/kyleeschen/Desktop/Ouroboros/ob/src/ob/clojure.cljs","^G",566,"^H",7,"^I",566,"^J",16,"^K",["^L",["^M",["^L",[["~$&","^P"]]]]],"^1A","Takes a body of expressions that returns an ISeq or nil, and yields\n  a ISeqable object that will invoke the body only the first time seq\n  is called, and will cache the result and return it on all subsequent\n  seq calls.","^1>",["^ ","^U",true,"^1?",0,"^Y",0,"^R",[["^L",["^P"]]],"^K",["^L",[["~$&","^P"]]],"^T",["^L",[null]]]],"^:","~$ob.clojure/lazy-seq*","^F","src/ob/clojure.cljs","^J",16,"^1>",["^ ","^U",true,"^1?",0,"^Y",0,"^R",[["^L",["^P"]]],"^K",["^L",[["~$&","^P"]]],"^T",["^L",[null]]],"^R",[["^L",["^P"]]],"^S",null,"^1?",0,"^T",["^L",[null]],"^H",1,"^U",true,"^1C",[["^ ","^1?",0,"^U",true,"^1:",["^9",["^1Q","^1R"]]]],"^G",566,"^V","^X","^I",566,"^Y",0,"^Z",true,"^K",["^L",[["~$&","^P"]]],"^1A","Takes a body of expressions that returns an ISeq or nil, and yields\n  a ISeqable object that will invoke the body only the first time seq\n  is called, and will cache the result and return it on all subsequent\n  seq calls."],"~$macroexpand-all*",["^ ","^D",null,"^E",["^ ","^F","/Users/kyleeschen/Desktop/Ouroboros/ob/src/ob/clojure.cljs","^G",499,"^H",7,"^I",499,"^J",23,"^K",["^L",["^M",["^L",[["^10"]]]]]],"^:","~$ob.clojure/macroexpand-all*","^F","src/ob/clojure.cljs","^J",23,"^R",["^L",[["^10"]]],"^S",null,"^T",["^L",[null,null]],"^H",1,"^U",false,"^G",499,"^V","^X","^I",499,"^Y",1,"^Z",true,"^K",["^L",["^M",["^L",[["^10"]]]]]],"~$MACROEXPAND",["^ ","^:","~$ob.clojure/MACROEXPAND","^F","src/ob/clojure.cljs","^G",479,"^H",1,"^I",479,"^J",17,"^E",["^ ","^F","/Users/kyleeschen/Desktop/Ouroboros/ob/src/ob/clojure.cljs","^G",479,"^H",6,"^I",479,"^J",17],"^1:",["^9",["^W","^2:","^1E"]]],"~$eval*",["^ ","^:","~$ob.clojure/eval*","^F","src/ob/clojure.cljs","^G",33,"^H",1,"^I",33,"^J",16,"^E",["^ ","^F","/Users/kyleeschen/Desktop/Ouroboros/ob/src/ob/clojure.cljs","^G",33,"^H",11,"^I",33,"^J",16],"^1:","~$cljs.core/MultiFn"],"^N",["^ ","^:","~$ob.clojure/env","^F","src/ob/clojure.cljs","^G",630,"^H",1,"^I",630,"^J",9,"^E",["^ ","^F","/Users/kyleeschen/Desktop/Ouroboros/ob/src/ob/clojure.cljs","^G",630,"^H",6,"^I",630,"^J",9],"^1:","^27"],"~$pathcache57841",["^ ","^16",true,"^E",["^ ","^17",true,"^16",true,"^18",true,"^F",null],"^18",true,"^:","~$ob.clojure/pathcache57841","^F","src/ob/clojure.cljs","^H",3,"^G",492,"^17",true,"^1:","^1;"],"~$or*",["^ ","^D",null,"^E",["^ ","^F","/Users/kyleeschen/Desktop/Ouroboros/ob/src/ob/clojure.cljs","^G",522,"^H",7,"^I",522,"^J",10,"^K",["^L",["^M",["^L",[[],["~$x"],["~$x","~$&","^1N"]]]]],"^1A","Evaluates exprs one at a time, from left to right. If a form\n  returns a logical true value, or returns that value and doesn't\n  evaluate any of the other expressions, otherwise it returns the\n  value of the last expression. (or) returns nil.","^1>",["^ ","^U",true,"^1?",1,"^Y",1,"^R",[[],["~$x"]],"^K",["^L",[[],["~$x"],["~$x","~$&","^1N"]]],"^T",["^L",[null,null,null]]]],"^:","~$ob.clojure/or*","^F","src/ob/clojure.cljs","^J",10,"^1>",["^ ","^U",true,"^1?",1,"^Y",1,"^R",[[],["~$x"]],"^K",["^L",[[],["~$x"],["~$x","~$&","^1N"]]],"^T",["^L",[null,null,null]]],"^R",[[],["~$x"]],"^S",null,"^1?",1,"^T",["^L",[null,null,null]],"^H",1,"^U",true,"^1C",[["^ ","^1?",0,"^U",false,"^1:","^1E"],["^ ","^1?",1,"^U",false],["^ ","^1?",1,"^U",true,"^1:",["^9",["^1Q","^1R"]]]],"^G",522,"^I",522,"^Y",1,"^Z",true,"^K",["^L",[[],["~$x"],["~$x","~$&","^1N"]]],"^1A","Evaluates exprs one at a time, from left to right. If a form\n  returns a logical true value, or returns that value and doesn't\n  evaluate any of the other expressions, otherwise it returns the\n  value of the last expression. (or) returns nil."],"~$op->macro-fn",["^ ","^:","~$ob.clojure/op->macro-fn","^F","src/ob/clojure.cljs","^G",604,"^H",1,"^I",604,"^J",18,"^E",["^ ","^F","/Users/kyleeschen/Desktop/Ouroboros/ob/src/ob/clojure.cljs","^G",604,"^H",6,"^I",604,"^J",18],"^1:","^27"],"~$pathcache57801",["^ ","^16",true,"^E",["^ ","^17",true,"^16",true,"^18",true,"^F",null],"^18",true,"^:","~$ob.clojure/pathcache57801","^F","src/ob/clojure.cljs","^H",15,"^G",342,"^17",true,"^1:","^1;"],"~$run-bindings",["^ ","^:","~$ob.clojure/run-bindings","^F","src/ob/clojure.cljs","^G",114,"^H",1,"^I",114,"^J",18,"^E",["^ ","^F","/Users/kyleeschen/Desktop/Ouroboros/ob/src/ob/clojure.cljs","^G",114,"^H",6,"^I",114,"^J",18],"^1:","^2I"],"~$eval-sexpr",["^ ","^:","~$ob.clojure/eval-sexpr","^F","src/ob/clojure.cljs","^G",41,"^H",1,"^I",41,"^J",21,"^E",["^ ","^F","/Users/kyleeschen/Desktop/Ouroboros/ob/src/ob/clojure.cljs","^G",41,"^H",11,"^I",41,"^J",21],"^1:","^2Y"],"~$alter-macroexpand-node?",["^ ","^D",null,"^E",["^ ","^F","/Users/kyleeschen/Desktop/Ouroboros/ob/src/ob/clojure.cljs","^G",463,"^H",7,"^I",463,"^J",30,"^K",["^L",["^M",["^L",[["~$node"]]]]]],"^:","~$ob.clojure/alter-macroexpand-node?","^F","src/ob/clojure.cljs","^J",30,"^R",["^L",[["^3<"]]],"^S",null,"^T",["^L",[null,null]],"^H",1,"^U",false,"^G",463,"^V","^1P","^I",463,"^Y",1,"^Z",true,"^K",["^L",["^M",["^L",[["^3<"]]]]]],"~$redistribute-ids",["^ ","^D",null,"^E",["^ ","^F","/Users/kyleeschen/Desktop/Ouroboros/ob/src/ob/clojure.cljs","^G",490,"^H",7,"^I",490,"^J",23,"^K",["^L",["^M",["^L",[["^3<"]]]]]],"^:","~$ob.clojure/redistribute-ids","^F","src/ob/clojure.cljs","^J",23,"^R",["^L",[["^3<"]]],"^S",null,"^T",["^L",[null,null]],"^H",1,"^U",false,"^G",490,"^V","^X","^I",490,"^Y",1,"^Z",true,"^K",["^L",["^M",["^L",[["^3<"]]]]]],"~$run-args",["^ ","^:","~$ob.clojure/run-args","^F","src/ob/clojure.cljs","^G",100,"^H",1,"^I",100,"^J",14,"^E",["^ ","^F","/Users/kyleeschen/Desktop/Ouroboros/ob/src/ob/clojure.cljs","^G",100,"^H",6,"^I",100,"^J",14],"^1:","^2I"],"~$pathcache57838",["^ ","^16",true,"^E",["^ ","^17",true,"^16",true,"^18",true,"^F",null],"^18",true,"^:","~$ob.clojure/pathcache57838","^F","src/ob/clojure.cljs","^H",3,"^G",480,"^17",true,"^1:","^1;"]],"~:cljs.spec/registry-ref",[],"~:require-macros",["^ ","^4","^4","~$s","^4","^>","^>","^6","^6"],"~:cljs.analyzer/constants",["^ ","~:seen",["^9",["^4","~$&","~$s/cond-path","~$x","^1@","~:cc?","~$seq?","^3=","^P","^1<","~:s-exprs","^32","~$s/ALL","~$=","^1P","~:let","~:fn","^2>","~$cljs.core/=","~$p","~$ALL-WITH-META","~:do","~:invoked-cc","^1T","^1M","~$stay-then-continue","~:else","^1S","~:if","~:lambda","~$y","~:return","~:default","^1=","~:ns","~:symbol","^:","~$*","~$cljs.core/LazySeq","~:constant","~$lazy-seq","^2V","~$cljs.core","^F","~$and__57847__auto__","~$->","~:bind-local","^28","^J","^1B","^1>","^2R","~:params","~$fn","^2;","~:recur","^2=","~$s/FIRST","~$do","~$when-not","^2B","~$when","^R","~$number","~$cljs.core/-","^1?","~:op","~:env","~:letfn","~:recur-point","~:invoke?","~$if","^T","~$new","^1U","~:k","~:sym","^H","~:loop","~$com.rpl.specter/stay-then-continue","~:call-with-current-continuation","~$-","~$cljs.core//","~$or","~$cljs.core/let","~$com.rpl.specter/STAY","^1O","^U","~$s/if-path","~$com.rpl.specter/FIRST","~:set!","^2Q","~$cond-path","^G","^29","~$fn*","~:quote","^2U","~$s/ALL-WITH-META","~$com.rpl.specter/if-path","~:id","~$cljs.core/*","^31","~$s/stay-then-continue","~$or__57856__auto__","~$/","^3<","~$cljs.core/fn","~$loop","^2C","~$STAY","^I","~$p1__57837#","~:invoke","~:throw","^2?","^2<","~$cond","~:f","~$com.rpl.specter/ALL","~:def","^Y","~$FIRST","~:lambda-exit","~:form","^1:","~$+","~$com.rpl.specter/cond-path","^3;","~$p1__57836#","~$cljs.core/symbol?","^1N","^K","~$cljs.core/and","~:hierarchy","~$list?","~:body","~$s/STAY","^1A","~:collection","^;","~:figwheel-hooks","~$com.rpl.specter/ALL-WITH-META","~$cljs.core/or","~:test","~$cljs.core/+","~$and","~$symbol?","~$more","~$->>","~$if-path","~$ALL"]],"~:order",["^5>","^3Z","^3K","^5B","^3X","^3T","^3W","^4@","~:k","^4?","^4F","^45","^59","^40","^47","^4B","^5@","^46","^3V","^58","~:f","^52","^3I","^4C","^3N","^3U","^3Q","^4S","^3M","^4G","^48","^4A","^5D","^3Y","^:","^F","^J","^H","^G","^I","^K","^1A","^5F","^4","^3P","^4T","^4[","^55","^5M","^3L","^4O","^57","^49","^56","^4P","^53","^4I","^3R","^4V","^5:","^4Q","^3H","^5<","^1:","^42","^5I","^1P","~$x","^4M","^50","^5A","^3=","^;","^5C","^3;","^3<","^4H","^3S","^4X","~$p","^4U","^5L","^4N","^4R","^5;","^4K","^3J","^5?","^51","^29","^28","^2V","^2U","^4L","^43","^4D","^5=","^4Y","^5E","^4E","^3[","^4Z","^54","^4:","^5H","^44","^5K","^4<","^4;","^41","^1B","^1=","^1>","^1<","^U","^1?","^Y","^R","^T","^1@","~$&","^1O","^1M","^1N","^32","^31","^2<","^2;","^1T","^1U","^1S","^2?","^2=","^2>","^P","^2C","^2B","^2R","^2Q","~$-","~$+","~$*","~$/","~$=","^4>","~$y","^5J","^4=","^5G","^4W","^4J","^3O"]],"^1A",null]